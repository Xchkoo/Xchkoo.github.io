<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>很久以前的dt炮搭建笔记</title>
    <url>/2021-02-26_2021-02-26/</url>
    <content><![CDATA[<hr>
<p><img src="/2021-02-26_2021-02-26/2.png" alt="2"><br><img src="/2021-02-26_2021-02-26/1.png" alt="1"></p>
<hr>
<blockquote><p>不是那个dt嗷wwww</p>
<footer><strong>————Xchkoo</strong></footer></blockquote>

<p> <a href="http://xchkoo.github.io/2021-02-26_2021-02-26/">http://xchkoo.github.io/2021-02-26_2021-02-26/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>俄罗斯方块</category>
        <category>攻略</category>
      </categories>
      <tags>
        <tag>俄罗斯方块</tag>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title>bilibili［不负责评测第Ⅰ期］500元价位无敌手—寒冰赛睿5</title>
    <url>/2021-02-01-1/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=48622792&cid=85186403&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

<p> <a href="http://xchkoo.github.io/2021-02-01-1/">http://xchkoo.github.io/2021-02-01-1/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>bilibili</category>
        <category>不负责评测</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
        <tag>不负责评测</tag>
      </tags>
  </entry>
  <entry>
    <title>HowToComment</title>
    <url>/HowToComment_2021-03-31/</url>
    <content><![CDATA[<h1 id="ISSUE"><a href="#ISSUE" class="headerlink" title="ISSUE"></a>ISSUE</h1><p>diaspora的主题自带gitalk，可是先前一直没有办法显示.<br>会提示:</p>
<blockquote>
<p>“未找到相关的Issues进行评论 请联系@**** 初始化创建<br>“,点击”使用GitHub”登录的时候,跳回网站首页。</p>
</blockquote>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>这个问题困扰了我很久，在<a herf="https://blog.csdn.net/Cirzearchenille/article/details/88802534">这个博客</a>里的实例给了解决方法.<br>问题在于github oauth app的一个选项<br>Authorization callback URL里应该是填cname的域名</p>
<blockquote>
<p>C A L L B A C K！<br><img src="/HowToComment_2021-03-31/callback.png" alt="callback"></p>
</blockquote>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>总而言之，实现后效果是这样：<br><img src="/HowToComment_2021-03-31/CommentExample.png" alt="CommentExample"><br>效果很好，孩子很开心(｡･∀･)ﾉﾞ</p>
<p> <a href="http://xchkoo.github.io/HowToComment_2021-03-31/">http://xchkoo.github.io/HowToComment_2021-03-31/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>hexo</category>
        <category>gitalk</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title>ReDen it</title>
    <url>/ReDen-it_2021-02-26/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=886892272&cid=303122741&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>


<p> <a href="http://xchkoo.github.io/ReDen-it_2021-02-26/">http://xchkoo.github.io/ReDen-it_2021-02-26/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>bilibili</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>[归并排序]luogu-P1908逆序对 题解</title>
    <url>/MergeSort_2021-02-04/</url>
    <content><![CDATA[<h3 id="！！！如果无法显示模板效果，请刷新网页一下！！！"><a href="#！！！如果无法显示模板效果，请刷新网页一下！！！" class="headerlink" title="！！！如果无法显示模板效果，请刷新网页一下！！！"></a>！！！如果无法显示模板效果，请刷新网页一下！！！</h3><h2 id="מּ-מּ-！-color-darkviolet-归并排序"><a href="#מּ-מּ-！-color-darkviolet-归并排序" class="headerlink" title="( מּ,_מּ)！$\color{darkviolet}{归并排序}$"></a>( מּ,_מּ)！$\color{darkviolet}{归并排序}$</h2><h4 id="1-归并排序简介"><a href="#1-归并排序简介" class="headerlink" title="1. 归并排序简介"></a>1. 归并排序简介</h4><blockquote>
<p>归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，$\color{red}{该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。}$将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p align="right">————百度百科</p><p></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">复杂度</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">时间复杂度</td>
<td align="center">$\mathcal{O}(nlogn)$</td>
</tr>
<tr>
<td align="center">空间复杂度</td>
<td align="center">$\mathcal{T}(n)$</td>
</tr>
</tbody></table>
<p><img src="/MergeSort_2021-02-04/mergesort.webp" alt="原理图解"></p>
<p>归并排序简要概括一下就是————两个步骤：二分 -&gt; 合并(排序的重要步骤)</p>
<h4 id="2-归并排序原理"><a href="#2-归并排序原理" class="headerlink" title="2. 归并排序原理"></a>2. 归并排序原理</h4><h5 id="1-二分"><a href="#1-二分" class="headerlink" title="1. 二分"></a>1. 二分</h5><p>正如简介所言，归并排序函数<code>void msort(int b,int e)</code>是一个递归函数。</p>
<pre><code class="cpp">        if(b == e)
        return;
    int mid=(b+e)/2,i=b,j=mid+1,k=b;
    msort(b,mid),msort(mid+1,e);
    //理解递归只需知道你设计这个递归函数的功能，中间的递归过程就不用管了。
</code></pre>
<p>这一步进行递归二分数组直到不可再分 即b(begin)指针和e(end)指针指向同一位置。</p>
<ol start="2">
<li>合并<pre><code class="cpp">while(i &lt;= mid&amp;&amp;j &lt;= e)
     if(o[i]&lt;=o[j])
         tem[k++]=o[i++];
     else
         tem[k++]=o[j++];
</code></pre>
</li>
</ol>
<pre><code>i,j是指向左数组和右数组的开头的指针
在合并时我们遵守一个原则：将左边的和右边的元素比较，谁小谁先进数组。
逻辑上分为：
$\color&#123;green&#125;&#123;1. i &lt; j 且 a[i] &lt; a[j]时 我们将i指向的元素保存至临时数组tem中。&#125;$
$\color&#123;green&#125;&#123;2. i &lt; j 且 a[i] &gt; a[j]时 我们将j指向的元素保存至临时数组tem中。&#125;$

可是这样轮次放置，可能会出现一边的数组先轮完了，这就是第2、3个while，轮完就意味着不需要再比较了，可以直接放入。
$\color&#123;green&#125;&#123;3. i &lt;= mid 的情况 就直接tem[k++]=o[i++];&#125;$
$\color&#123;green&#125;&#123;   j &lt;= e 的情况   tem[k++]=o[j++];&#125;$
``` cpp
    while(i&lt;=mid)
        tem[k++]=o[i++];
    while(j&lt;=e)
        tem[k++]=o[j++];
</code></pre>
<p>别忘了我们的数组是放在临时数组里的，结束时要放回主数组，毕竟接下来还要递归。</p>
<pre><code class="cpp">    for(int l=b;l&lt;=e;l++)
        o[l]=tem[l];
</code></pre>
<h4 id="3-原题-amp-AC代码"><a href="#3-原题-amp-AC代码" class="headerlink" title="3. 原题&amp;AC代码"></a>3. <a href="https://www.luogu.com.cn/problem/P1908">原题</a>&amp;AC代码</h4><p>解题思路:<br>逆序对就是$1，2，3，4，5$这样顺的数组中出了一个二五仔（如 ${1，2，3，5，4}$ 的情况 ${5，4}$ 就算一组逆序对）,那么二五仔的数量就是我们在归并时else的情况的集合。</p>
<pre><code class="cpp">while(i &lt;= mid&amp;&amp;j &lt;= e)
        if(o[i]&lt;=o[j])
            tem[k++]=o[i++];
        else
            tem[k++]=o[j++],ans+=mid-i+1;
</code></pre>
<p>所以，逆序对的数量实际上就是我们将数组归并排序时发生交换的元素数量。<br>只要在归并排序的源码上加上计算ans的步骤就行了。</p>
<p>$\color{red}{AC代码}$：</p>
<pre><code class="cpp">/*
 * © Copyright 2021 Xchkoo All rights reserved.
 * Author: Xchkoo
 * Date: 2021-02-04 5:40
 * LISENSE: CC v4.0 BY-SA https://creativecommons.org/licenses/by-sa/4.0/deed.zh
 * Remark: Thanks for viewing XD
 * Welcome to my blog -&gt; Xchkoo.top 
 */
#include&lt;iostream&gt;
#define N 500010
using namespace std;
int n;
int o[N];//Main
int tem[N];//Temporary
long long ans;

void msort(int b,int e)// b = begin e = end
&#123;
    if(b == e)
        return;
    int mid=(b+e)/2,i=b,j=mid+1,k=b;
    msort(b,mid),msort(mid+1,e);
    while(i &lt;= mid&amp;&amp;j &lt;= e)
        if(o[i]&lt;=o[j])
            tem[k++]=o[i++];
        else
            tem[k++]=o[j++],ans+=mid-i+1;//count answer
    while(i&lt;=mid)
        tem[k++]=o[i++];
    while(j&lt;=e)
        tem[k++]=o[j++];
    for(int l=b;l&lt;=e;l++)
        o[l]=tem[l];
&#125;           

int main()
&#123;
    ios::sync_with_stdio(false);
    cin &gt;&gt; n;
    for(int i=1;i&lt;=n;i++)&#123;
        cin &gt;&gt; o[i];
    &#125;
    msort(1,n);
    cout &lt;&lt; ans;
    return 0;
&#125;
</code></pre>
<p> <a href="http://xchkoo.github.io/MergeSort_2021-02-04/">http://xchkoo.github.io/MergeSort_2021-02-04/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>排序</category>
        <category>归并排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>归并排序</tag>
        <tag>luogu-P1908 逆序对</tag>
        <tag>题解</tag>
        <tag>Mergesort</tag>
      </tags>
  </entry>
  <entry>
    <title>bilibili-无用各类游戏素材垃圾箱</title>
    <url>/bilibili-%E6%97%A0%E7%94%A8%E5%90%84%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%B4%A0%E6%9D%90%E5%9E%83%E5%9C%BE%E7%AE%B1_2021-02-18/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=289131496&cid=299134491&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>


<p> <a href="http://xchkoo.github.io/bilibili-%E6%97%A0%E7%94%A8%E5%90%84%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%B4%A0%E6%9D%90%E5%9E%83%E5%9C%BE%E7%AE%B1_2021-02-18/">http://xchkoo.github.io/bilibili-无用各类游戏素材垃圾箱_2021-02-18/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>bilibili</category>
        <category>game</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>初日上第九课笔记</title>
    <url>/japanese-learning-note-01_2021-02-08/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="./note.pdf" width="100%" height="550" type="application/pdf">
	</div>




























<hr>
<blockquote><p>如果你的浏览器没有pdf插件<br>那它就是个垃圾</p>
<footer><strong>——XCHKOO</strong></footer></blockquote>
<p><img src="/japanese-learning-note-01_2021-02-08/note(1).jpg" alt="note(1)"><br><img src="/japanese-learning-note-01_2021-02-08/note(2).jpg" alt="note(2)"><br><img src="/japanese-learning-note-01_2021-02-08/note(3).jpg" alt="note(3)"><br><img src="/japanese-learning-note-01_2021-02-08/note(4).jpg" alt="note(4)"><br><img src="/japanese-learning-note-01_2021-02-08/note(5).jpg" alt="note(5)"></p>
<hr>
<p> <a href="http://xchkoo.github.io/japanese-learning-note-01_2021-02-08/">http://xchkoo.github.io/japanese-learning-note-01_2021-02-08/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>日语</category>
        <category>学习笔记</category>
        <category>初级标准日本语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>myplan</title>
    <url>/myplan_2021-03-31/</url>
    <content><![CDATA[<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><ul>
<li><p>日语学习</p>
<blockquote>
<ol>
<li>目标完成初级上册的学习</li>
<li>目标看懂《游戏人生》日版1-2册</li>
<li>目标在洛谷翻译一道日语题</li>
</ol>
</blockquote>
</li>
<li><p>前端学习</p>
<blockquote>
<ol>
<li>hexo的博客更新</li>
<li>vue和react等主流框架的学习</li>
<li>项目的完善</li>
</ol>
</blockquote>
</li>
<li><p>算法学习</p>
<blockquote>
<ol>
<li><a href="https://www.luogu.com.cn/training/9391">https://www.luogu.com.cn/training/9391</a><br>综合题单的学习</li>
<li>线段树、ddp、倍增……</li>
</ol>
</blockquote>
</li>
<li><p>游戏框架学习</p>
<blockquote>
<ol>
<li>unity 2d</li>
<li>虚幻4 2d<br><a href="https://www.unrealengine.com/zh-CN/learn">https://www.unrealengine.com/zh-CN/learn</a></li>
</ol>
</blockquote>
</li>
<li><p>ae、pr学习</p>
</li>
<li><p>音乐制作学习</p>
</li>
</ul>
<p> <a href="http://xchkoo.github.io/myplan_2021-03-31/">http://xchkoo.github.io/myplan_2021-03-31/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>计划</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>[匈牙利算法-最小覆盖点]POJ3041题解</title>
    <url>/post1/</url>
    <content><![CDATA[<h2 id="最小点覆盖"><a href="#最小点覆盖" class="headerlink" title="最小点覆盖"></a>最小点覆盖</h2><h4 id="例题-POJ3041"><a href="#例题-POJ3041" class="headerlink" title="例题: POJ3041"></a><font color="red" size="3">例题</font>: <a href="http://poj.org/problem?id=3041">POJ3041</a></h4><h4 id="理解：-有图G-U-V-，求删去最小点可删去所有边的步骤即求最小点覆盖的过程"><a href="#理解：-有图G-U-V-，求删去最小点可删去所有边的步骤即求最小点覆盖的过程" class="headerlink" title="理解： 有图G{U,V}，求删去最小点可删去所有边的步骤即求最小点覆盖的过程"></a><font color="red" size="3">理解</font>： 有图G{U,V}，求删去最小点可删去所有边的步骤即求最小点覆盖的过程</h4><hr>
<h5 id="二分图最大匹配的Konig定理及其证明-过于困难-gt-见-http-www-matrix67-com-blog-archives-116"><a href="#二分图最大匹配的Konig定理及其证明-过于困难-gt-见-http-www-matrix67-com-blog-archives-116" class="headerlink" title="二分图最大匹配的König定理及其证明(过于困难)-&gt;见[http://www.matrix67.com/blog/archives/116]"></a>二分图最大匹配的<font color="red" size="3">König定理</font>及其证明(过于困难)-&gt;见[<a href="http://www.matrix67.com/blog/archives/116]">http://www.matrix67.com/blog/archives/116]</a></h5><hr>
<h5 id="结论版-Konig定理"><a href="#结论版-Konig定理" class="headerlink" title="结论版 König定理 :"></a>结论版<font color="red" size="5"> König定理</font> :</h5><ol>
<li>由X侧匹配失败的一点回溯所有边（可见图） 并给走过的点打上标记</li>
<li>X侧未打标记的点和X对侧打标记的点集就是最小点覆盖</li>
</ol>
<h2 id><a href="#" class="headerlink" title></a><img src="/post1/post1-img1.jpg" alt="post1-img1"></h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a><strong>代码:</strong></h3><pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=500+10;

struct Max_Match
&#123;
    int n;
    bool g[maxn][maxn];
    bool vis[maxn];
    int left[maxn];

    void init(int n)
    &#123;
        this-&gt;n=n;
        memset(g,0,sizeof(g));
        memset(left,-1,sizeof(left));
    &#125;

    bool match(int u)
    &#123;
        for(int v=1;v&lt;=n;v++)if(g[u][v] &amp;&amp; !vis[v])
        &#123;
            vis[v]=true;
            if(left[v]==-1 || match(left[v]))
            &#123;
                left[v]=u;
                return true;
            &#125;
        &#125;
        return false;
    &#125;

    int solve()
    &#123;
        int ans=0;
        for(int i=1;i&lt;=n;i++)
        &#123;
            memset(vis,0,sizeof(vis));
            if(match(i)) ans++;
        &#125;
        return ans;
    &#125;
&#125;MM;

int main()
&#123;
    int n,k;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    MM.init(n);
    while(k--)
    &#123;
        int u,v;
        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
        MM.g[u][v]=true;
    &#125;
    printf(&quot;%d\n&quot;,MM.solve());
    return 0;
&#125;
</code></pre>
<hr>
<h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a><a href="https://zhuanlan.zhihu.com/p/96229700">参考博客</a></h5><p> <a href="http://xchkoo.github.io/post1/">http://xchkoo.github.io/post1/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>图论</category>
        <category>匈牙利算法</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>匈牙利算法</tag>
        <tag>最小覆盖点</tag>
      </tags>
  </entry>
  <entry>
    <title>爷 有 片 头 了 ！！！</title>
    <url>/post2/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=798539826&cid=279518850&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

<p> <a href="http://xchkoo.github.io/post2/">http://xchkoo.github.io/post2/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>bilibili</category>
        <category>csgo</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
        <tag>csgo</tag>
      </tags>
  </entry>
  <entry>
    <title>We have a simple ARG here!</title>
    <url>/post3/</url>
    <content><![CDATA[<h2 id="0876"><a href="#0876" class="headerlink" title="0876***%"></a>0876***%</h2><p> <a href="http://xchkoo.github.io/post3/">http://xchkoo.github.io/post3/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <tags>
        <tag>ARG</tag>
      </tags>
  </entry>
  <entry>
    <title>我愿称之为超级缝合怪——本人2021代码规范</title>
    <url>/standards_2021-04-02/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>为防止coding过程中码风的不断切换导致的可读性差，本人特意编写了一套主要继承于python、go语法和GNU\LINUX规范的代码规范。</p>
<hr>

<p>本人(Xchkoo)代码规范应遵循以下条例:</p>
<h3 id="一、-color-darkviolet-首项"><a href="#一、-color-darkviolet-首项" class="headerlink" title="一、 $\color{darkviolet}{首项}$"></a>一、 $\color{darkviolet}{首项}$</h3><ol>
<li><p>所有左大括号都不应换行并应在前加一个空格。</p>
</li>
<li><p>所有逗号后都应该有一个空格。</p>
</li>
<li><p>规定TAB键是4个空格，不应连续出现2个以上的空格。</p>
</li>
<li><p>代码块后应空一行，文件结束处应换行（遵循python规范）。</p>
</li>
<li><p>所有注释都应该是<code>/* ... */</code>，不能出现<code>//</code> 。</p>
</li>
<li><p>在例如oi等算法题程序不能使用linker的项目中必须将cpp文件分为3个块(block)：全局变量声明块、函数与类块、main块。<br>应用<code>/* ... */</code>包括起来，使用类似jinja2的语法。但start和end要大写。<br>块与块之间要有两行空行。<br>例：</p>
<pre><code>/* START global variate block */
 ....    
/* END global variate block */
</code></pre>
<p>块内可以有小块(part),小块之间用一行空行分隔。<br>例：</p>
<pre><code>/* START tree part */
...
/* END */
</code></pre>
<p>tips:在jinja2中，end不需要但提倡写出block名。</p>
<h3 id="二、-color-darkviolet-变量"><a href="#二、-color-darkviolet-变量" class="headerlink" title="二、 $\color{darkviolet}{变量}$"></a>二、 $\color{darkviolet}{变量}$</h3></li>
<li><p>绝对不可出现毫无意义的缩写如next-&gt;nxt，但广为使用的number-&gt;num是合理的。</p>
</li>
<li><p>绝对不可用拼音命名变量（同理于函数和类）但是用日语罗马字应大加赞赏。</p>
</li>
<li><p>变量命名不提倡驼峰命名法，应使用蛇形命名法且只能使用_分割单词。（驼峰命名法应该在变量名过长有过多_时使用）注意！：-及——非法。</p>
</li>
</ol>
<h3 id="三、-color-darkviolet-语句、函数和类"><a href="#三、-color-darkviolet-语句、函数和类" class="headerlink" title="三、  $\color{darkviolet}{语句、函数和类}$"></a>三、  $\color{darkviolet}{语句、函数和类}$</h3><ol>
<li><p>若语句为单行 应只在块和语句中加一个空格<br>例：<code>if(...) continue;</code></p>
</li>
<li><p>函数应同理于python，在开头使用注释编写帮助文档：</p>
<pre><code>/* 在此处写下帮助文档 */ 。
</code></pre>
</li>
<li><p>类中的变量和方法应该命名为<code>simplifiedClassName_name</code>。</p>
</li>
<li><p>类名应大写首字母。</p>
</li>
<li><p>不应使用《C++ primer》中不提倡的类用法。</p>
</li>
<li><p>应封装类中变量，提供接口。</p>
</li>
<li><p>类应尽量富鲁棒性。</p>
</li>
</ol>
<h3 id="四、-color-darkviolet-命名空间"><a href="#四、-color-darkviolet-命名空间" class="headerlink" title="四、 $\color{darkviolet}{命名空间}$"></a>四、 $\color{darkviolet}{命名空间}$</h3><p>  在oi题中应遵循剃刀原则即使用<code>using namespace std</code>。<br>  在项目中应使用<code>std::</code>。</p>
<h4 id="Xchkoo-reserves-all-the-right-for-the-final-explanation"><a href="#Xchkoo-reserves-all-the-right-for-the-final-explanation" class="headerlink" title="*** Xchkoo reserves all the right for the final explanation ***"></a><div align="justify" style="color:red;">*** Xchkoo reserves all the right for the final explanation ***</div></h4><hr>

<p><img src="/standards_2021-04-02/1.webp" alt="配图"></p>
<p> <a href="http://xchkoo.github.io/standards_2021-04-02/">http://xchkoo.github.io/standards_2021-04-02/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>coding</category>
        <category>code standards</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>code standards</tag>
      </tags>
  </entry>
  <entry>
    <title>vlog-游杭州野生动物园</title>
    <url>/theVisitOfZoo/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=802701194&cid=325467633&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>


<p> <a href="http://xchkoo.github.io/theVisitOfZoo/">http://xchkoo.github.io/theVisitOfZoo/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>vlog</category>
      </categories>
      <tags>
        <tag>vlog</tag>
        <tag>高中</tag>
        <tag>生活</tag>
        <tag>旅游</tag>
        <tag>春游</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]洛谷-P3384 模板题重链剖分-线段树</title>
    <url>/p3384_2021-04-05/</url>
    <content><![CDATA[<h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><p>视频大约一个小时，需要加载半分钟左右。</p>
<iframe src="//player.bilibili.com/player.html?aid=459949113&cid=319890611&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

<h1 id="原题和值得参考的博客"><a href="#原题和值得参考的博客" class="headerlink" title="原题和值得参考的博客"></a>原题和值得参考的博客</h1><ul>
<li><a href="https://www.luogu.com.cn/problem/P3384">p3384</a></li>
<li><a href="https://oi-wiki.org/graph/hld/">oi-wiki 树链剖分</a></li>
<li><a href="https://oi-wiki.org/ds/seg/">oi-wiki 线段树</a></li>
<li><a href="https://www.cnblogs.com/chinhhh/p/7965433.html">参考 树链剖分详解</a></li>
<li><a href="https://www.luogu.com.cn/blog/zengqinyi/solution-p3384">参考 洛谷优秀题解</a></li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码有详细的注释，不理解可以看视频。</p>
<pre><code class="cpp">/*
 * © Copyright 2021 Xchkoo All rights reserved.
 *
 * AUTHOR: Xchkoo
 * DATE: 2021-04-02
 * LISENSE: CC v4.0 BY-SA https://creativecommons.org/licenses/by-sa/4.0/deed.zh
 * Welcome to my blog -&gt; https://Xchkoo.top/
 */
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;/*这个cstring里有个memset是不得不用啊*/

#define mid ((l+r)&gt;&gt;1)
#define lson rt&lt;&lt;1,l,mid
#define rson rt&lt;&lt;1|1,mid+1,r
#define len (r-l+1)
/* 这段主要是为了线段树，手敲太麻烦了 */
typedef long long ll;
typedef size_t s_t;
#define mem(a,b) memset(a,(b),sizeof(a))
using namespace std;


/* START global variate block */

const int MAXN = 100000+10;
int n, m, r, mod,cnt=1,dfs2_cnt,res=0;
int head[MAXN],segment_tree[MAXN&lt;&lt;1],value[MAXN],wt[MAXN],lazy[MAXN&lt;&lt;1],depth[MAXN],father[MAXN],node_size[MAXN],heavy_son[MAXN],array_top[MAXN],id[MAXN];

/* END global variate block */


/* START function and class block */

/* START tree part */

struct Node &#123;
    int next, to;
&#125; e[MAXN&lt;&lt;1];

void add_edge(int u, int v) &#123;
    e[cnt].next = head[u];
    e[cnt].to = v;
    head[u] = cnt; 
    cnt++;
&#125;

/* END */

/* START segment tree part */
/* 实际上我们把线段树函数单独拎出来，将线段树通过一个范围参数传入 */
void pushdown(int rt,int size)
/* 
 * 这块是懒标记,相比起lowbit这个其实好理解一点。
 * 懒标记意味着它不会主动更新，它把这个操作储存到结点的lazy属性中（在c++中我们通过使用lazy数组来实现），
 * 当有用到这个结点和这个结点的子树时（比如查询的dfs滚到这里了），我们会将懒标记打破，分配到每个它的子树，
 * 当这个懒标记滚到叶子结点的时候，懒标记就转换成值加入叶子结点的值属性。
 * ————————————————————————————————————————————————————————————————————
 * 回到题目可能能更好理解一点，题目的操作3是要给指定的范围加值（1、2要用到hld我们先放着），
 * 比方现在的范围是3-8，我们有一条1-10的线段并且我们在这个线段上建立了一棵线段树。
 * 于是我们给3、8的lca（最近公共祖先）加个懒标记。
 * 现在有个操作要查询3-4的数据，可以，我们于是从root开始向3-4出发
 * 在这个时候我们发现root有一个懒标记属性，遵从定义我们把它打碎，分配给子结点
 * （注意：我们是在把3-8共同加一个值吧！注意“共同”！）。
 * 现在我们查找3-4时就会以这个顺序
 *                             1-10-&gt;|1-5  -&gt;|1-3  -&gt;|1-2-...
 *                           |       |        |2-3 -&gt;| 2  HERE        
 *                           |       |               | 3
 *                           |       |3-5  -&gt;|3-4  HERE
 *                           |5-10 -...      |4-5-...
 * 在同时我们会顺便把懒标记推下去，最终推到2 和 3-4 
 * 这里要一个转化：我们是在把3-8共同加一个值，共同意味着3-4这个区间其实要3加一次4加一次，
 * 总共要加两次。所以在求和时要乘上子结点个数。
 * 理解了的话就看代码吧：
 */
&#123;
    /* 左右子节点都加上父节点的lazy属性 */
    lazy[rt&lt;&lt;1]+=lazy[rt];
    lazy[rt&lt;&lt;1|1]+=lazy[rt];
    
    /* 这里是左右结点把lazy打破的过程 
     * 注意：segment_tree是一个线段树结点的值的集合，
     * 不是叶子结点的结点的值 是其子树所有结点的值的和。
     * 所以在传递懒标记的过程中我们应当把这个结点的值也更新了。
     */
    segment_tree[rt&lt;&lt;1]+=lazy[rt]*(size-(size&gt;&gt;1));
    segment_tree[rt&lt;&lt;1|1]+=lazy[rt]*(size&gt;&gt;1);
    segment_tree[rt&lt;&lt;1]%=mod;
    segment_tree[rt&lt;&lt;1|1]%=mod;
    lazy[rt]=0;
&#125;

void build(int rt,int l,int r)
/*
 * 此函数是在建立一棵线段树，
 * 因为我们在处理操作3、4时并不需要树链剖分，
 * 直接在原来树的基础上就可以了。
 */
&#123;
    if(l == r)
    /*
     * 当左範圍等于右範圍，
     * 它的范围就是一，也就是一个叶子结点，
     * 这个条件意味着可以结束递归了。
     */
    &#123;
        segment_tree[rt] = wt[l];
        if(segment_tree[rt]&gt;mod) segment_tree[rt]%=mod;
        /*
         * 别忘了题目有取模的操作。
         * 另外取模有个法则 （a+b) mod c = （a mod c + b mod c）mod c
         * 可以用阿贝尔群证明。
         */
        return;
    &#125;
    build(lson);/* 递归 lson和rson定义在宏里 */
    build(rson);
    /*
     * 线段树是一棵二叉树，
     * 可以想象、用纸推一下这个性质，
     * 左子树序号一定是父节点的两倍，右子树一定是父节点的两倍加1
     * （在这里因为左子树序号是个偶数，所以它的二进制末位一定是0，
     * 用|位操作符来|1其实就是加1，用位操作符比用+更快，是一个优化）
     */
    segment_tree[rt]=(segment_tree[rt&lt;&lt;1] + segment_tree[rt&lt;&lt;1|1])%mod;
&#125;

void query(int rt,int l,int r,int L,int R)
/* 查询函数 小写l、r 是查询范围，大写L、R是线段树的范围*/
&#123;
    if(L&lt;=l&amp;&amp;r&lt;=R) &#123; /* 如果在范围内 加上这个结点的值*/
        res+=segment_tree[rt];
        res%=mod;
        return;
    &#125;
    /* 
     * #define lson rt&lt;&lt;1,l,mid
     * #define rson rt&lt;&lt;1|1,mid+1,r 
    */
    else /* 如果是在跨范围的就分成两块递归，如果这个结点还有懒标记属性，就先打破懒标记 */
    &#123;
        if(lazy[rt])pushdown(rt,len);
        if(L&lt;=mid)query(lson,L,R);  
        if(R&gt;mid)query(rson,L,R);
    &#125;
&#125;

void update(int rt,int l,int r,int L,int R,int k)//1 1 5 0 
/* 区间更新函数  大至同理于区间查询函数*/
&#123;
    if(L&lt;=l&amp;&amp;r&lt;=R) &#123;
        lazy[rt]+=k;/* 这里就是应该用懒标记的地方 */
        segment_tree[rt]+=k*len; /* 乘以个数在pushdown函数中有解释 */
    &#125;
    else &#123;
        if(lazy[rt]) pushdown(rt,len);/* 如果有懒标记打破 */
        /* 跨区间就分开处理 */
        if(L&lt;=mid) update(lson,L,R,k);
        if(R&gt;mid) update(rson,L,R,k);
        segment_tree[rt]=(segment_tree[rt&lt;&lt;1]+segment_tree[rt&lt;&lt;1|1])%mod;
    &#125;
&#125;

/* END */

/* START execute part */
/*
 * 这一部分是针对操作1234的实际操作部分，
 * 3、4就是基本的线段树
 * 接下来着重讲1、2操作。
 * 
 */
int query_lca(int x,int y)&#123;
    int ans=0;
    while(array_top[x]!=array_top[y])&#123;//当两个点不在同一条链上 
        if(depth[array_top[x]]&lt;depth[array_top[y]])swap(x,y);//把x点改为所在链顶端的深度更深的那个点
        res=0;
        query(1,1,n,id[array_top[x]],id[x]);//ans加上x点到x所在链顶端 这一段区间的点权和
        ans+=res;
        ans%=mod;//按题意取模 
        x=father[array_top[x]];//把x跳到x所在链顶端的那个点的上面一个点
    &#125;
    //直到两个点处于一条链上
    if(depth[x]&gt;depth[y])swap(x,y);//把x点深度更深的那个点
    res=0;
    query(1,1,n,id[x],id[y]);//这时再加上此时两个点的区间和即可
    ans+=res;
    return ans%mod;
&#125;

void update_lca(int x,int y,int k)&#123;//同上 
    k%=mod;
    while(array_top[x]!=array_top[y])&#123;
        if(depth[array_top[x]]&lt;depth[array_top[y]])swap(x,y);
        update(1,1,n,id[array_top[x]],id[x],k);
        x=father[array_top[x]];
    &#125;
    if(depth[x]&gt;depth[y])swap(x,y);
    update(1,1,n,id[x],id[y],k);
&#125;

int query_segment_tree(int x)&#123;
    res=0;
    query(1,1,n,id[x],id[x]+node_size[x]-1);//子树区间右端点为id[x]+siz[x]-1 
    return res;
&#125;

void update_segment_tree(int x,int k)&#123;//同上 //4 2
    update(1,1,n,id[x],id[x]+node_size[x]-1,k); //1 1 5 0 0 2
&#125;

/* END */

/* START Heavy-light Decomposition part */

void hld_dfs1(int x, int fa, int deep)
/*
 * 这个dfs1用来进行重链剖分的第一次递归，
 * 找到重子结点，并把它的heavy son通过数组记录。
 * 接下来就可以进行dfs2把heavy son连成heavy_edge。
 */
&#123;
    depth[x] = deep;/* lca */
    father[x] = fa;/* 这里的father数组实际上是重链连接起来的关键，详见dfs2 */
    node_size[x] = 1;
    int heavy_son_size = -1;
    for(int i=head[x];i;i=e[i].next) &#123;
        int to = e[i].to;
        if(to == fa) continue;/*若为父亲则跳过*/
        hld_dfs1(to, x, deep+1);/*dfs它的儿子*/ 
        node_size[x] += node_size[to];/*把它的儿子size加到它身上,遍历完后就会得到它的size*/
        if(node_size[to] &gt; heavy_son_size) &#123;
            heavy_son[x]=to;
            heavy_son_size=node_size[to];
            /* tips:一个父亲只有一个heavy son，
             * 如果有两个大小一样的heavy son，
             * 那就任选一个，不会对结果造成影响。
             */
        &#125;
    &#125;
&#125;

void hld_dfs2(int x,int top)
/*
 * 这个dfs是用来把heavy son连成heavy_edge的。
 * 一个heavy_edge一般有1个属性————顶点
 * 我们会记录它，因为链的dfs序是连续的，所以跳的过程也遵循dfs序，
 * 所以在接下来的lca中我们可以通过顶点的父亲来跳链。
 */
&#123;
    /* 接下来这两步是在对原先的序号重编为dfs序
     *（因为这段在一个dfs中，所以dfs2_cnt的自增会保证它是一个dfs序）。
     * top就是我们说的链顶。 -&gt; https://oi-wiki.org/graph/hld/
     */
    id[x]=++dfs2_cnt;
    wt[dfs2_cnt]=value[x];
    array_top[x] = top;
    if(!heavy_son[x]) return;
    /* 没有heavy_son意味着这一条重链我们已经遍历到尾了 */
    /* 按先处理重儿子，再处理轻儿子的顺序递归处理 */
    hld_dfs2(heavy_son[x],top);/* 重儿子 */
    for(int i=head[x];i;i=e[i].next)/* 轻儿子 */
    &#123;
        int to = e[i].to;
        if(to==father[x]||to==heavy_son[x]) continue;
        hld_dfs2(to,to);
    &#125;
&#125;

/* END */

/* END function and class block */


/* START main block */

int main() &#123;
    //freopen(&quot;p3384.in&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;p3384.out&quot;, &quot;w&quot;, stdout);
    ios::sync_with_stdio(false);
    /* n: num of node
     * m: num of the execution
     * r: root&#39;s serial number
     * p: the mod num
     */
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; mod;
    for(int i=1;i&lt;=n;i++)
        cin &gt;&gt; value[i];
    int a,b;
    for(int i=1;i&lt;n;i++) &#123;
        cin &gt;&gt; a &gt;&gt; b;
        add_edge(a,b);
        add_edge(b,a);
    &#125;
    hld_dfs1(r,0,1); // 2 0 1
    hld_dfs2(r,r);
    /* for exec 1,2 */
    build(1,1,n);
    /* for exec 3,4 */
    while(m--) &#123;
        int x,y,w,exec;
        cin &gt;&gt; exec;
        /* 对操作进行处理：
         * 一共有四个操作
         * 操作1：格式：1 x y z 表示将树从 x 到 y 结点最短路径上所有节点的值都加上 z。
         * 操作2：格式：2 x y 表示求树从 x 到 y 结点最短路径上所有节点的值之和。
         * 操作3：格式：3 x z 表示将以 x 为根节点的子树内所有节点值都加上 z。
         * 操作4：格式：4 x 表示求以 x 为根节点的子树内所有节点值之和
         */
        if(exec == 1)&#123;
            cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;
            update_lca(x,y,w);
        &#125;
        else if(exec == 2) &#123;
            cin &gt;&gt; x &gt;&gt; y;
            cout &lt;&lt; query_lca(x,y)&lt;&lt;endl;
        &#125;
        else if(exec == 3) &#123;
            cin &gt;&gt; x &gt;&gt; w;
            update_segment_tree(x,w);//4 2
        &#125;
        else if(exec == 4) &#123;
            cin &gt;&gt; x;
            cout &lt;&lt; query_segment_tree(x)&lt;&lt;endl;
        &#125;
    &#125;
    cin.get();
&#125;

/* END main block */
//(rt=1, l=1, r=5, L=0, R=-1, k=2)
//Breakpoint 1, update_segment_tree (x=4, k=2) at p3384.cpp:208
//208         update(1,1,n,id[x],id[x]+node_size[x]-1,k);
//(gdb) p id
//$1 = &#123;0, 0, 1, 0 &lt;repeats 100007 times&gt;&#125;
//(gdb) p node_size
//$2 = &#123;0, 0, 1, 0 &lt;repeats 100007 times&gt;&#125;
</code></pre>
<p> <a href="http://xchkoo.github.io/p3384_2021-04-05/">http://xchkoo.github.io/p3384_2021-04-05/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>重链剖分</tag>
        <tag>hld</tag>
        <tag>线段树</tag>
        <tag>懒标记</tag>
        <tag>luogu-P3384 模板题</tag>
      </tags>
  </entry>
</search>
