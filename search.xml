<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>bilibili［不负责评测第Ⅰ期］500元价位无敌手—寒冰赛睿5</title>
    <url>/2021-02-01-1/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=48622792&cid=85186403&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

<p> <a href="http://xchkoo.github.io/2021-02-01-1/">http://xchkoo.github.io/2021-02-01-1/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>bilibili</category>
        <category>不负责评测</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
        <tag>不负责评测</tag>
      </tags>
  </entry>
  <entry>
    <title>很久以前的dt炮搭建笔记</title>
    <url>/2021-02-26_2021-02-26/</url>
    <content><![CDATA[<hr>
<p><img src="/2021-02-26_2021-02-26/2.png" alt="2"><br><img src="/2021-02-26_2021-02-26/1.png" alt="1"></p>
<hr>
<blockquote><p>不是那个dt嗷wwww</p>
<footer><strong>————Xchkoo</strong></footer></blockquote>

<p> <a href="http://xchkoo.github.io/2021-02-26_2021-02-26/">http://xchkoo.github.io/2021-02-26_2021-02-26/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>俄罗斯方块</category>
        <category>攻略</category>
      </categories>
      <tags>
        <tag>俄罗斯方块</tag>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title>HowToComment</title>
    <url>/HowToComment_2021-03-31/</url>
    <content><![CDATA[<h1 id="ISSUE"><a href="#ISSUE" class="headerlink" title="ISSUE"></a>ISSUE</h1><p>diaspora的主题自带gitalk，可是先前一直没有办法显示.<br>会提示:</p>
<blockquote>
<p>“未找到相关的Issues进行评论 请联系@**** 初始化创建<br>“,点击”使用GitHub”登录的时候,跳回网站首页。</p>
</blockquote>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>这个问题困扰了我很久，在<a herf="https://blog.csdn.net/Cirzearchenille/article/details/88802534">这个博客</a>里的实例给了解决方法.<br>问题在于github oauth app的一个选项<br>Authorization callback URL里应该是填cname的域名</p>
<blockquote>
<p>C A L L B A C K！<br><img src="/HowToComment_2021-03-31/callback.png" alt="callback"></p>
</blockquote>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>总而言之，实现后效果是这样：<br><img src="/HowToComment_2021-03-31/CommentExample.png" alt="CommentExample"><br>效果很好，孩子很开心(｡･∀･)ﾉﾞ</p>
<p> <a href="http://xchkoo.github.io/HowToComment_2021-03-31/">http://xchkoo.github.io/HowToComment_2021-03-31/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>hexo</category>
        <category>gitalk</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>hexo</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title>ReDen it</title>
    <url>/ReDen-it_2021-02-26/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=886892272&cid=303122741&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>


<p> <a href="http://xchkoo.github.io/ReDen-it_2021-02-26/">http://xchkoo.github.io/ReDen-it_2021-02-26/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>bilibili</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>[归并排序]luogu-P1908逆序对 题解</title>
    <url>/MergeSort_2021-02-04/</url>
    <content><![CDATA[<h3 id="！！！如果无法显示模板效果，请刷新网页一下！！！"><a href="#！！！如果无法显示模板效果，请刷新网页一下！！！" class="headerlink" title="！！！如果无法显示模板效果，请刷新网页一下！！！"></a>！！！如果无法显示模板效果，请刷新网页一下！！！</h3><h2 id="מּ-מּ-！-color-darkviolet-归并排序"><a href="#מּ-מּ-！-color-darkviolet-归并排序" class="headerlink" title="( מּ,_מּ)！$\color{darkviolet}{归并排序}$"></a>( מּ,_מּ)！$\color{darkviolet}{归并排序}$</h2><h4 id="1-归并排序简介"><a href="#1-归并排序简介" class="headerlink" title="1. 归并排序简介"></a>1. 归并排序简介</h4><blockquote>
<p>归并排序（Merge Sort）是建立在归并操作上的一种有效，稳定的排序算法，$\color{red}{该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。}$将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p align="right">————百度百科</p><p></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">复杂度</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">时间复杂度</td>
<td align="center">$\mathcal{O}(nlogn)$</td>
</tr>
<tr>
<td align="center">空间复杂度</td>
<td align="center">$\mathcal{T}(n)$</td>
</tr>
</tbody></table>
<p><img src="/MergeSort_2021-02-04/mergesort.webp" alt="原理图解"></p>
<p>归并排序简要概括一下就是————两个步骤：二分 -&gt; 合并(排序的重要步骤)</p>
<h4 id="2-归并排序原理"><a href="#2-归并排序原理" class="headerlink" title="2. 归并排序原理"></a>2. 归并排序原理</h4><h5 id="1-二分"><a href="#1-二分" class="headerlink" title="1. 二分"></a>1. 二分</h5><p>正如简介所言，归并排序函数<code>void msort(int b,int e)</code>是一个递归函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(b == e)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid=(b+e)/<span class="number">2</span>,i=b,j=mid+<span class="number">1</span>,k=b;</span><br><span class="line">  msort(b,mid),msort(mid+<span class="number">1</span>,e);</span><br><span class="line">  <span class="comment">//理解递归只需知道你设计这个递归函数的功能，中间的递归过程就不用管了。</span></span><br></pre></td></tr></table></figure>
<p>这一步进行递归二分数组直到不可再分 即b(begin)指针和e(end)指针指向同一位置。</p>
<ol start="2">
<li>合并<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt;= mid&amp;&amp;j &lt;= e)</span><br><span class="line">   	<span class="keyword">if</span>(o[i]&lt;=o[j])</span><br><span class="line">   		tem[k++]=o[i++];</span><br><span class="line">   	<span class="keyword">else</span></span><br><span class="line">   		tem[k++]=o[j++];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
i,j是指向左数组和右数组的开头的指针<br>在合并时我们遵守一个原则：将左边的和右边的元素比较，谁小谁先进数组。<br>逻辑上分为：<br>$\color{green}{1. i &lt; j 且 a[i] &lt; a[j]时 我们将i指向的元素保存至临时数组tem中。}$<br>$\color{green}{2. i &lt; j 且 a[i] &gt; a[j]时 我们将j指向的元素保存至临时数组tem中。}$</li>
</ol>
<p>可是这样轮次放置，可能会出现一边的数组先轮完了，这就是第2、3个while，轮完就意味着不需要再比较了，可以直接放入。<br>$\color{green}{3. i &lt;= mid 的情况 就直接tem[k++]=o[i++];}$<br>$\color{green}{   j &lt;= e 的情况   tem[k++]=o[j++];}$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">	tem[k++]=o[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=e)</span><br><span class="line">	tem[k++]=o[j++];</span><br></pre></td></tr></table></figure>
<p>别忘了我们的数组是放在临时数组里的，结束时要放回主数组，毕竟接下来还要递归。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=b;l&lt;=e;l++)</span><br><span class="line">	o[l]=tem[l];</span><br></pre></td></tr></table></figure>

<h4 id="3-原题-amp-AC代码"><a href="#3-原题-amp-AC代码" class="headerlink" title="3. 原题&amp;AC代码"></a>3. <a href="https://www.luogu.com.cn/problem/P1908">原题</a>&amp;AC代码</h4><p>解题思路:<br>逆序对就是$1，2，3，4，5$这样顺的数组中出了一个二五仔（如 ${1，2，3，5，4}$ 的情况 ${5，4}$ 就算一组逆序对）,那么二五仔的数量就是我们在归并时else的情况的集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt;= mid&amp;&amp;j &lt;= e)</span><br><span class="line">    	<span class="keyword">if</span>(o[i]&lt;=o[j])</span><br><span class="line">    		tem[k++]=o[i++];</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    		tem[k++]=o[j++],ans+=mid-i+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>所以，逆序对的数量实际上就是我们将数组归并排序时发生交换的元素数量。<br>只要在归并排序的源码上加上计算ans的步骤就行了。</p>
<p>$\color{red}{AC代码}$：</p>
<figure class="highlight cpp"><figcaption><span>Xchkoo-p1908-code</span><a href="https://Xchkoo.top/">Xchkoo</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * © Copyright 2021 Xchkoo All rights reserved.</span></span><br><span class="line"><span class="comment"> * Author: Xchkoo</span></span><br><span class="line"><span class="comment"> * Date: 2021-02-04 5:40</span></span><br><span class="line"><span class="comment"> * LISENSE: CC v4.0 BY-SA https://creativecommons.org/licenses/by-sa/4.0/deed.zh</span></span><br><span class="line"><span class="comment"> * Remark: Thanks for viewing XD</span></span><br><span class="line"><span class="comment"> * Welcome to my blog -&gt; Xchkoo.top </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> o[N];<span class="comment">//Main</span></span><br><span class="line"><span class="keyword">int</span> tem[N];<span class="comment">//Temporary</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> b,<span class="keyword">int</span> e)</span><span class="comment">// b = begin e = end</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == e)</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(b+e)/<span class="number">2</span>,i=b,j=mid+<span class="number">1</span>,k=b;</span><br><span class="line">    msort(b,mid),msort(mid+<span class="number">1</span>,e);</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid&amp;&amp;j &lt;= e)</span><br><span class="line">    	<span class="keyword">if</span>(o[i]&lt;=o[j])</span><br><span class="line">    		tem[k++]=o[i++];</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    		tem[k++]=o[j++],ans+=mid-i+<span class="number">1</span>;<span class="comment">//count answer</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">    	tem[k++]=o[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=e)</span><br><span class="line">    	tem[k++]=o[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l=b;l&lt;=e;l++)</span><br><span class="line">    	o[l]=tem[l];</span><br><span class="line">&#125;           </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; o[i];</span><br><span class="line">    &#125;</span><br><span class="line">    msort(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <a href="http://xchkoo.github.io/MergeSort_2021-02-04/">http://xchkoo.github.io/MergeSort_2021-02-04/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>排序</category>
        <category>归并排序</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>归并排序</tag>
        <tag>luogu-P1908 逆序对</tag>
        <tag>题解</tag>
        <tag>Mergesort</tag>
      </tags>
  </entry>
  <entry>
    <title>bilibili-无用各类游戏素材垃圾箱</title>
    <url>/bilibili-%E6%97%A0%E7%94%A8%E5%90%84%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%B4%A0%E6%9D%90%E5%9E%83%E5%9C%BE%E7%AE%B1_2021-02-18/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=289131496&cid=299134491&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>


<p> <a href="http://xchkoo.github.io/bilibili-%E6%97%A0%E7%94%A8%E5%90%84%E7%B1%BB%E6%B8%B8%E6%88%8F%E7%B4%A0%E6%9D%90%E5%9E%83%E5%9C%BE%E7%AE%B1_2021-02-18/">http://xchkoo.github.io/bilibili-无用各类游戏素材垃圾箱_2021-02-18/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>bilibili</category>
        <category>game</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>初日上第九课笔记</title>
    <url>/japanese-learning-note-01_2021-02-08/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="./note.pdf" width="100%" height="550" type="application/pdf">
	</div>




























<hr>
<blockquote><p>如果你的浏览器没有pdf插件<br>那它就是个垃圾</p>
<footer><strong>——XCHKOO</strong></footer></blockquote>
<p><img src="/japanese-learning-note-01_2021-02-08/note(1).jpg" alt="note(1)"><br><img src="/japanese-learning-note-01_2021-02-08/note(2).jpg" alt="note(2)"><br><img src="/japanese-learning-note-01_2021-02-08/note(3).jpg" alt="note(3)"><br><img src="/japanese-learning-note-01_2021-02-08/note(4).jpg" alt="note(4)"><br><img src="/japanese-learning-note-01_2021-02-08/note(5).jpg" alt="note(5)"></p>
<hr>
<p> <a href="http://xchkoo.github.io/japanese-learning-note-01_2021-02-08/">http://xchkoo.github.io/japanese-learning-note-01_2021-02-08/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>日语</category>
        <category>学习笔记</category>
        <category>初级标准日本语</category>
      </categories>
      <tags>
        <tag>日语</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>myplan</title>
    <url>/myplan_2021-03-31/</url>
    <content><![CDATA[<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><ul>
<li><p>日语学习</p>
<blockquote>
<ol>
<li>目标完成初级上册的学习</li>
<li>目标看懂《游戏人生》日版1-2册</li>
<li>目标在洛谷翻译一道日语题</li>
</ol>
</blockquote>
</li>
<li><p>前端学习</p>
<blockquote>
<ol>
<li>hexo的博客更新</li>
<li>vue和react等主流框架的学习</li>
<li>项目的完善</li>
</ol>
</blockquote>
</li>
<li><p>算法学习</p>
<blockquote>
<ol>
<li><a href="https://www.luogu.com.cn/training/9391">https://www.luogu.com.cn/training/9391</a><br>综合题单的学习</li>
<li>线段树、ddp、倍增……</li>
</ol>
</blockquote>
</li>
<li><p>游戏框架学习</p>
<blockquote>
<ol>
<li>unity 2d</li>
<li>虚幻4 2d<br><a href="https://www.unrealengine.com/zh-CN/learn">https://www.unrealengine.com/zh-CN/learn</a></li>
</ol>
</blockquote>
</li>
<li><p>ae、pr学习</p>
</li>
<li><p>音乐制作学习</p>
</li>
</ul>
<p> <a href="http://xchkoo.github.io/myplan_2021-03-31/">http://xchkoo.github.io/myplan_2021-03-31/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>计划</category>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>[题解]洛谷-P3384 模板题重链剖分-线段树</title>
    <url>/p3384_2021-04-05/</url>
    <content><![CDATA[<h1 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h1><p>视频大约一个小时，需要加载半分钟左右。</p>
<iframe src="//player.bilibili.com/player.html?aid=459949113&cid=319890611&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

<h1 id="原题和值得参考的博客"><a href="#原题和值得参考的博客" class="headerlink" title="原题和值得参考的博客"></a>原题和值得参考的博客</h1><ul>
<li><a href="https://www.luogu.com.cn/problem/P3384">p3384</a></li>
<li><a href="https://oi-wiki.org/graph/hld/">oi-wiki 树链剖分</a></li>
<li><a href="https://oi-wiki.org/ds/seg/">oi-wiki 线段树</a></li>
<li><a href="https://www.cnblogs.com/chinhhh/p/7965433.html">参考 树链剖分详解</a></li>
<li><a href="https://www.luogu.com.cn/blog/zengqinyi/solution-p3384">参考 洛谷优秀题解</a></li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>代码有详细的注释，不理解可以看视频。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * © Copyright 2021 Xchkoo All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * AUTHOR: Xchkoo</span></span><br><span class="line"><span class="comment"> * DATE: 2021-04-02</span></span><br><span class="line"><span class="comment"> * LISENSE: CC v4.0 BY-SA https://creativecommons.org/licenses/by-sa/4.0/deed.zh</span></span><br><span class="line"><span class="comment"> * Welcome to my blog -&gt; https://Xchkoo.top/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;/*这个cstring里有个memset是不得不用啊*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson rt&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> len (r-l+1)</span></span><br><span class="line"><span class="comment">/* 这段主要是为了线段树，手敲太麻烦了 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> <span class="keyword">s_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,(b),sizeof(a))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* START global variate block */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, r, mod,cnt=<span class="number">1</span>,dfs2_cnt,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> head[MAXN],segment_tree[MAXN&lt;&lt;<span class="number">1</span>],value[MAXN],wt[MAXN],lazy[MAXN&lt;&lt;<span class="number">1</span>],depth[MAXN],father[MAXN],node_size[MAXN],heavy_son[MAXN],array_top[MAXN],id[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* END global variate block */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* START function and class block */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* START tree part */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">&#125; e[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[cnt].next = head[u];</span><br><span class="line">    e[cnt].to = v;</span><br><span class="line">    head[u] = cnt; </span><br><span class="line">    cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* END */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* START segment tree part */</span></span><br><span class="line"><span class="comment">/* 实际上我们把线段树函数单独拎出来，将线段树通过一个范围参数传入 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* </span></span></span><br><span class="line"><span class="function"><span class="comment"> * 这块是懒标记,相比起lowbit这个其实好理解一点。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 懒标记意味着它不会主动更新，它把这个操作储存到结点的lazy属性中（在c++中我们通过使用lazy数组来实现），</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 当有用到这个结点和这个结点的子树时（比如查询的dfs滚到这里了），我们会将懒标记打破，分配到每个它的子树，</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 当这个懒标记滚到叶子结点的时候，懒标记就转换成值加入叶子结点的值属性。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * ————————————————————————————————————————————————————————————————————</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 回到题目可能能更好理解一点，题目的操作3是要给指定的范围加值（1、2要用到hld我们先放着），</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 比方现在的范围是3-8，我们有一条1-10的线段并且我们在这个线段上建立了一棵线段树。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 于是我们给3、8的lca（最近公共祖先）加个懒标记。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 现在有个操作要查询3-4的数据，可以，我们于是从root开始向3-4出发</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 在这个时候我们发现root有一个懒标记属性，遵从定义我们把它打碎，分配给子结点</span></span></span><br><span class="line"><span class="function"><span class="comment"> * （注意：我们是在把3-8共同加一个值吧！注意“共同”！）。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 现在我们查找3-4时就会以这个顺序</span></span></span><br><span class="line"><span class="function"><span class="comment"> *                             1-10-&gt;|1-5  -&gt;|1-3  -&gt;|1-2-...</span></span></span><br><span class="line"><span class="function"><span class="comment"> *                           |       |        |2-3 -&gt;| 2  HERE        </span></span></span><br><span class="line"><span class="function"><span class="comment"> *                           |       |               | 3</span></span></span><br><span class="line"><span class="function"><span class="comment"> *                           |       |3-5  -&gt;|3-4  HERE</span></span></span><br><span class="line"><span class="function"><span class="comment"> *                           |5-10 -...      |4-5-...</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 在同时我们会顺便把懒标记推下去，最终推到2 和 3-4 </span></span></span><br><span class="line"><span class="function"><span class="comment"> * 这里要一个转化：我们是在把3-8共同加一个值，共同意味着3-4这个区间其实要3加一次4加一次，</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 总共要加两次。所以在求和时要乘上子结点个数。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 理解了的话就看代码吧：</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 左右子节点都加上父节点的lazy属性 */</span></span><br><span class="line">    lazy[rt&lt;&lt;<span class="number">1</span>]+=lazy[rt];</span><br><span class="line">    lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[rt];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 这里是左右结点把lazy打破的过程 </span></span><br><span class="line"><span class="comment">     * 注意：segment_tree是一个线段树结点的值的集合，</span></span><br><span class="line"><span class="comment">     * 不是叶子结点的结点的值 是其子树所有结点的值的和。</span></span><br><span class="line"><span class="comment">     * 所以在传递懒标记的过程中我们应当把这个结点的值也更新了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    segment_tree[rt&lt;&lt;<span class="number">1</span>]+=lazy[rt]*(size-(size&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    segment_tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[rt]*(size&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    segment_tree[rt&lt;&lt;<span class="number">1</span>]%=mod;</span><br><span class="line">    segment_tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%=mod;</span><br><span class="line">    lazy[rt]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 此函数是在建立一棵线段树，</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 因为我们在处理操作3、4时并不需要树链剖分，</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 直接在原来树的基础上就可以了。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当左範圍等于右範圍，</span></span><br><span class="line"><span class="comment">     * 它的范围就是一，也就是一个叶子结点，</span></span><br><span class="line"><span class="comment">     * 这个条件意味着可以结束递归了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &#123;</span><br><span class="line">        segment_tree[rt] = wt[l];</span><br><span class="line">        <span class="keyword">if</span>(segment_tree[rt]&gt;mod) segment_tree[rt]%=mod;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 别忘了题目有取模的操作。</span></span><br><span class="line"><span class="comment">         * 另外取模有个法则 （a+b) mod c = （a mod c + b mod c）mod c</span></span><br><span class="line"><span class="comment">         * 可以用阿贝尔群证明。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    build(lson);<span class="comment">/* 递归 lson和rson定义在宏里 */</span></span><br><span class="line">    build(rson);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 线段树是一棵二叉树，</span></span><br><span class="line"><span class="comment">     * 可以想象、用纸推一下这个性质，</span></span><br><span class="line"><span class="comment">     * 左子树序号一定是父节点的两倍，右子树一定是父节点的两倍加1</span></span><br><span class="line"><span class="comment">     * （在这里因为左子树序号是个偶数，所以它的二进制末位一定是0，</span></span><br><span class="line"><span class="comment">     * 用|位操作符来|1其实就是加1，用位操作符比用+更快，是一个优化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    segment_tree[rt]=(segment_tree[rt&lt;&lt;<span class="number">1</span>] + segment_tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"><span class="comment">/* 查询函数 小写l、r 是查询范围，大写L、R是线段树的范围*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123; <span class="comment">/* 如果在范围内 加上这个结点的值*/</span></span><br><span class="line">        res+=segment_tree[rt];</span><br><span class="line">        res%=mod;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * #define lson rt&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="comment">     * #define rson rt&lt;&lt;1|1,mid+1,r </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* 如果是在跨范围的就分成两块递归，如果这个结点还有懒标记属性，就先打破懒标记 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy[rt])pushdown(rt,len);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)query(lson,L,R);  </span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)query(rson,L,R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> k)</span><span class="comment">//1 1 5 0 </span></span></span><br><span class="line"><span class="function"><span class="comment">/* 区间更新函数  大至同理于区间查询函数*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) &#123;</span><br><span class="line">        lazy[rt]+=k;<span class="comment">/* 这里就是应该用懒标记的地方 */</span></span><br><span class="line">        segment_tree[rt]+=k*len; <span class="comment">/* 乘以个数在pushdown函数中有解释 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lazy[rt]) pushdown(rt,len);<span class="comment">/* 如果有懒标记打破 */</span></span><br><span class="line">        <span class="comment">/* 跨区间就分开处理 */</span></span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid) update(lson,L,R,k);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid) update(rson,L,R,k);</span><br><span class="line">        segment_tree[rt]=(segment_tree[rt&lt;&lt;<span class="number">1</span>]+segment_tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* END */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* START execute part */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这一部分是针对操作1234的实际操作部分，</span></span><br><span class="line"><span class="comment"> * 3、4就是基本的线段树</span></span><br><span class="line"><span class="comment"> * 接下来着重讲1、2操作。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(array_top[x]!=array_top[y])&#123;<span class="comment">//当两个点不在同一条链上 </span></span><br><span class="line">        <span class="keyword">if</span>(depth[array_top[x]]&lt;depth[array_top[y]])swap(x,y);<span class="comment">//把x点改为所在链顶端的深度更深的那个点</span></span><br><span class="line">        res=<span class="number">0</span>;</span><br><span class="line">        query(<span class="number">1</span>,<span class="number">1</span>,n,id[array_top[x]],id[x]);<span class="comment">//ans加上x点到x所在链顶端 这一段区间的点权和</span></span><br><span class="line">        ans+=res;</span><br><span class="line">        ans%=mod;<span class="comment">//按题意取模 </span></span><br><span class="line">        x=father[array_top[x]];<span class="comment">//把x跳到x所在链顶端的那个点的上面一个点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直到两个点处于一条链上</span></span><br><span class="line">    <span class="keyword">if</span>(depth[x]&gt;depth[y])swap(x,y);<span class="comment">//把x点深度更深的那个点</span></span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    query(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[y]);<span class="comment">//这时再加上此时两个点的区间和即可</span></span><br><span class="line">    ans+=res;</span><br><span class="line">    <span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//同上 </span></span><br><span class="line">    k%=mod;</span><br><span class="line">    <span class="keyword">while</span>(array_top[x]!=array_top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth[array_top[x]]&lt;depth[array_top[y]])swap(x,y);</span><br><span class="line">        update(<span class="number">1</span>,<span class="number">1</span>,n,id[array_top[x]],id[x],k);</span><br><span class="line">        x=father[array_top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(depth[x]&gt;depth[y])swap(x,y);</span><br><span class="line">    update(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[y],k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_segment_tree</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    query(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+node_size[x]<span class="number">-1</span>);<span class="comment">//子树区间右端点为id[x]+siz[x]-1 </span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_segment_tree</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//同上 //4 2</span></span><br><span class="line">    update(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+node_size[x]<span class="number">-1</span>,k); <span class="comment">//1 1 5 0 0 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* END */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* START Heavy-light Decomposition part */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hld_dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 这个dfs1用来进行重链剖分的第一次递归，</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 找到重子结点，并把它的heavy son通过数组记录。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 接下来就可以进行dfs2把heavy son连成heavy_edge。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    depth[x] = deep;<span class="comment">/* lca */</span></span><br><span class="line">    father[x] = fa;<span class="comment">/* 这里的father数组实际上是重链连接起来的关键，详见dfs2 */</span></span><br><span class="line">    node_size[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> heavy_son_size = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to == fa) <span class="keyword">continue</span>;<span class="comment">/*若为父亲则跳过*/</span></span><br><span class="line">        hld_dfs1(to, x, deep+<span class="number">1</span>);<span class="comment">/*dfs它的儿子*/</span> </span><br><span class="line">        node_size[x] += node_size[to];<span class="comment">/*把它的儿子size加到它身上,遍历完后就会得到它的size*/</span></span><br><span class="line">        <span class="keyword">if</span>(node_size[to] &gt; heavy_son_size) &#123;</span><br><span class="line">            heavy_son[x]=to;</span><br><span class="line">            heavy_son_size=node_size[to];</span><br><span class="line">            <span class="comment">/* tips:一个父亲只有一个heavy son，</span></span><br><span class="line"><span class="comment">             * 如果有两个大小一样的heavy son，</span></span><br><span class="line"><span class="comment">             * 那就任选一个，不会对结果造成影响。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hld_dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> top)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 这个dfs是用来把heavy son连成heavy_edge的。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 一个heavy_edge一般有1个属性————顶点</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 我们会记录它，因为链的dfs序是连续的，所以跳的过程也遵循dfs序，</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 所以在接下来的lca中我们可以通过顶点的父亲来跳链。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 接下来这两步是在对原先的序号重编为dfs序</span></span><br><span class="line"><span class="comment">     *（因为这段在一个dfs中，所以dfs2_cnt的自增会保证它是一个dfs序）。</span></span><br><span class="line"><span class="comment">     * top就是我们说的链顶。 -&gt; https://oi-wiki.org/graph/hld/</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    id[x]=++dfs2_cnt;</span><br><span class="line">    wt[dfs2_cnt]=value[x];</span><br><span class="line">    array_top[x] = top;</span><br><span class="line">    <span class="keyword">if</span>(!heavy_son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 没有heavy_son意味着这一条重链我们已经遍历到尾了 */</span></span><br><span class="line">    <span class="comment">/* 按先处理重儿子，再处理轻儿子的顺序递归处理 */</span></span><br><span class="line">    hld_dfs2(heavy_son[x],top);<span class="comment">/* 重儿子 */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].next)<span class="comment">/* 轻儿子 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(to==father[x]||to==heavy_son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        hld_dfs2(to,to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* END */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* END function and class block */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* START main block */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;p3384.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;p3384.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="comment">/* n: num of node</span></span><br><span class="line"><span class="comment">     * m: num of the execution</span></span><br><span class="line"><span class="comment">     * r: root&#x27;s serial number</span></span><br><span class="line"><span class="comment">     * p: the mod num</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; value[i];</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        add_edge(a,b);</span><br><span class="line">        add_edge(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    hld_dfs1(r,<span class="number">0</span>,<span class="number">1</span>); <span class="comment">// 2 0 1</span></span><br><span class="line">    hld_dfs2(r,r);</span><br><span class="line">    <span class="comment">/* for exec 1,2 */</span></span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="comment">/* for exec 3,4 */</span></span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,w,exec;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; exec;</span><br><span class="line">        <span class="comment">/* 对操作进行处理：</span></span><br><span class="line"><span class="comment">         * 一共有四个操作</span></span><br><span class="line"><span class="comment">         * 操作1：格式：1 x y z 表示将树从 x 到 y 结点最短路径上所有节点的值都加上 z。</span></span><br><span class="line"><span class="comment">         * 操作2：格式：2 x y 表示求树从 x 到 y 结点最短路径上所有节点的值之和。</span></span><br><span class="line"><span class="comment">         * 操作3：格式：3 x z 表示将以 x 为根节点的子树内所有节点值都加上 z。</span></span><br><span class="line"><span class="comment">         * 操作4：格式：4 x 表示求以 x 为根节点的子树内所有节点值之和</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(exec == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">            update_lca(x,y,w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(exec == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query_lca(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(exec == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; w;</span><br><span class="line">            update_segment_tree(x,w);<span class="comment">//4 2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(exec == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query_segment_tree(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* END main block */</span></span><br><span class="line"><span class="comment">//(rt=1, l=1, r=5, L=0, R=-1, k=2)</span></span><br><span class="line"><span class="comment">//Breakpoint 1, update_segment_tree (x=4, k=2) at p3384.cpp:208</span></span><br><span class="line"><span class="comment">//208         update(1,1,n,id[x],id[x]+node_size[x]-1,k);</span></span><br><span class="line"><span class="comment">//(gdb) p id</span></span><br><span class="line"><span class="comment">//$1 = &#123;0, 0, 1, 0 &lt;repeats 100007 times&gt;&#125;</span></span><br><span class="line"><span class="comment">//(gdb) p node_size</span></span><br><span class="line"><span class="comment">//$2 = &#123;0, 0, 1, 0 &lt;repeats 100007 times&gt;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p> <a href="http://xchkoo.github.io/p3384_2021-04-05/">http://xchkoo.github.io/p3384_2021-04-05/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>重链剖分</tag>
        <tag>hld</tag>
        <tag>线段树</tag>
        <tag>懒标记</tag>
        <tag>luogu-P3384 模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>[匈牙利算法-最小覆盖点]POJ3041题解</title>
    <url>/post1/</url>
    <content><![CDATA[<h2 id="最小点覆盖"><a href="#最小点覆盖" class="headerlink" title="最小点覆盖"></a>最小点覆盖</h2><h4 id="例题-POJ3041"><a href="#例题-POJ3041" class="headerlink" title="例题: POJ3041"></a><font color="red" size="3">例题</font>: <a href="http://poj.org/problem?id=3041">POJ3041</a></h4><h4 id="理解：-有图G-U-V-，求删去最小点可删去所有边的步骤即求最小点覆盖的过程"><a href="#理解：-有图G-U-V-，求删去最小点可删去所有边的步骤即求最小点覆盖的过程" class="headerlink" title="理解： 有图G{U,V}，求删去最小点可删去所有边的步骤即求最小点覆盖的过程"></a><font color="red" size="3">理解</font>： 有图G{U,V}，求删去最小点可删去所有边的步骤即求最小点覆盖的过程</h4><hr>
<h5 id="二分图最大匹配的Konig定理及其证明-过于困难-gt-见-http-www-matrix67-com-blog-archives-116"><a href="#二分图最大匹配的Konig定理及其证明-过于困难-gt-见-http-www-matrix67-com-blog-archives-116" class="headerlink" title="二分图最大匹配的König定理及其证明(过于困难)-&gt;见[http://www.matrix67.com/blog/archives/116]"></a>二分图最大匹配的<font color="red" size="3">König定理</font>及其证明(过于困难)-&gt;见[<a href="http://www.matrix67.com/blog/archives/116]">http://www.matrix67.com/blog/archives/116]</a></h5><hr>
<h5 id="结论版-Konig定理"><a href="#结论版-Konig定理" class="headerlink" title="结论版 König定理 :"></a>结论版<font color="red" size="5"> König定理</font> :</h5><ol>
<li>由X侧匹配失败的一点回溯所有边（可见图） 并给走过的点打上标记</li>
<li>X侧未打标记的点和X对侧打标记的点集就是最小点覆盖</li>
</ol>
<h2 id><a href="#" class="headerlink" title></a><img src="/post1/post1-img1.jpg" alt="post1-img1"></h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a><strong>代码:</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Max_Match</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">bool</span> g[maxn][maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="keyword">int</span> left[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=n;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(left,<span class="number">-1</span>,<span class="keyword">sizeof</span>(left));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)<span class="keyword">if</span>(g[u][v] &amp;&amp; !vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(left[v]==<span class="number">-1</span> || match(left[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                left[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span>(match(i)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;MM;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    MM.init(n);</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        MM.g[u][v]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,MM.solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a><a href="https://zhuanlan.zhihu.com/p/96229700">参考博客</a></h5><p> <a href="http://xchkoo.github.io/post1/">http://xchkoo.github.io/post1/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>图论</category>
        <category>匈牙利算法</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>匈牙利算法</tag>
        <tag>最小覆盖点</tag>
      </tags>
  </entry>
  <entry>
    <title>爷 有 片 头 了 ！！！</title>
    <url>/post2/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=798539826&cid=279518850&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

<p> <a href="http://xchkoo.github.io/post2/">http://xchkoo.github.io/post2/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>bilibili</category>
        <category>csgo</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
        <tag>csgo</tag>
      </tags>
  </entry>
  <entry>
    <title>We have a simple ARG here!</title>
    <url>/post3/</url>
    <content><![CDATA[<h2 id="0876"><a href="#0876" class="headerlink" title="0876***%"></a>0876***%</h2><p> <a href="http://xchkoo.github.io/post3/">http://xchkoo.github.io/post3/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <tags>
        <tag>ARG</tag>
      </tags>
  </entry>
  <entry>
    <title>2021代码规范</title>
    <url>/standards_2021-04-02/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>为防止coding过程中码风的不断切换导致的可读性差，本人特意编写了一套主要继承于python、go语法和GNU\LINUX规范的代码规范。</p>
<hr>

<p>本人(Xchkoo)代码规范应遵循以下条例:</p>
<h3 id="一、-color-darkviolet-首项"><a href="#一、-color-darkviolet-首项" class="headerlink" title="一、 $\color{darkviolet}{首项}$"></a>一、 $\color{darkviolet}{首项}$</h3><ol>
<li><p>所有左大括号都不应换行并应在前加一个空格。</p>
</li>
<li><p>所有逗号后都应该有一个空格。</p>
</li>
<li><p>规定TAB键是4个空格，不应连续出现2个以上的空格。</p>
</li>
<li><p>代码块后应空一行，文件结束处应换行（遵循python规范）。</p>
</li>
<li><p>所有注释都应该是<code>/* ... */</code>，不能出现<code>//</code> 。</p>
</li>
<li><p>在例如oi等算法题程序不能使用linker的项目中必须将cpp文件分为3个块(block)：全局变量声明块、函数与类块、main块。<br>应用<code>/* ... */</code>包括起来，使用类似jinja2的语法。但start和end要大写。<br>块与块之间要有两行空行。<br>例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/* START global variate block */</span></span><br><span class="line">    ....    </span><br><span class="line"><span class="regexp">/* END global variate block */</span></span><br></pre></td></tr></table></figure>
<p>块内可以有小块(part),小块之间用一行空行分隔。<br>例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/* START tree part */</span></span><br><span class="line">...</span><br><span class="line"><span class="regexp">/* END */</span></span><br></pre></td></tr></table></figure>
<p>tips:在jinja2中，end不需要但提倡写出block名。</p>
<h3 id="二、-color-darkviolet-变量"><a href="#二、-color-darkviolet-变量" class="headerlink" title="二、 $\color{darkviolet}{变量}$"></a>二、 $\color{darkviolet}{变量}$</h3></li>
<li><p>绝对不可出现毫无意义的缩写如next-&gt;nxt，但广为使用的number-&gt;num是合理的。</p>
</li>
<li><p>绝对不可用拼音命名变量（同理于函数和类）但是用日语罗马字应大加赞赏。</p>
</li>
<li><p>变量命名不提倡驼峰命名法，应使用蛇形命名法且只能使用_分割单词。（驼峰命名法应该在变量名过长有过多_时使用）注意！：-及——非法。</p>
</li>
</ol>
<h3 id="三、-color-darkviolet-语句、函数和类"><a href="#三、-color-darkviolet-语句、函数和类" class="headerlink" title="三、  $\color{darkviolet}{语句、函数和类}$"></a>三、  $\color{darkviolet}{语句、函数和类}$</h3><ol>
<li><p>若语句为单行 应只在块和语句中加一个空格<br>例：<code>if(...) continue;</code></p>
</li>
<li><p>函数应同理于python，在开头使用注释编写帮助文档：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/* 在此处写下帮助文档 */</span> 。</span><br></pre></td></tr></table></figure></li>
<li><p>类中的变量和方法应该命名为<code>simplifiedClassName_name</code>。</p>
</li>
<li><p>类名应大写首字母。</p>
</li>
<li><p>不应使用《C++ primer》中不提倡的类用法。</p>
</li>
<li><p>应封装类中变量，提供接口。</p>
</li>
<li><p>类应尽量富鲁棒性。</p>
</li>
</ol>
<h3 id="四、-color-darkviolet-命名空间"><a href="#四、-color-darkviolet-命名空间" class="headerlink" title="四、 $\color{darkviolet}{命名空间}$"></a>四、 $\color{darkviolet}{命名空间}$</h3><p>  在oi题中应遵循剃刀原则即使用<code>using namespace std</code>。<br>  在项目中应使用<code>std::</code>。</p>
<h4 id="Xchkoo-reserves-all-the-right-for-the-final-explanation"><a href="#Xchkoo-reserves-all-the-right-for-the-final-explanation" class="headerlink" title="*** Xchkoo reserves all the right for the final explanation ***"></a><div align="justify" style="color:red;">*** Xchkoo reserves all the right for the final explanation ***</div></h4><hr>

<p><img src="/standards_2021-04-02/1.webp" alt="配图"></p>
<p> <a href="http://xchkoo.github.io/standards_2021-04-02/">http://xchkoo.github.io/standards_2021-04-02/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>coding</category>
        <category>code standards</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>code standards</tag>
      </tags>
  </entry>
  <entry>
    <title>vlog-游杭州野生动物园</title>
    <url>/theVisitOfZoo/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=802701194&cid=325467633&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>


<p> <a href="http://xchkoo.github.io/theVisitOfZoo/">http://xchkoo.github.io/theVisitOfZoo/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>生活</category>
        <category>vlog</category>
      </categories>
      <tags>
        <tag>vlog</tag>
        <tag>高中</tag>
        <tag>生活</tag>
        <tag>旅游</tag>
        <tag>春游</tag>
      </tags>
  </entry>
  <entry>
    <title>秒速5厘米阅读笔记</title>
    <url>/byousokugosenchimiitoru-01/</url>
    <content><![CDATA[<p>将持续更新<br><img src="/byousokugosenchimiitoru-01/01.jpg" alt="01"></p>
<p> <a href="http://xchkoo.github.io/byousokugosenchimiitoru-01/">http://xchkoo.github.io/byousokugosenchimiitoru-01/</a> 本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>进行许可。</p>
]]></content>
      <categories>
        <category>japanese</category>
      </categories>
      <tags>
        <tag>japanese</tag>
        <tag>book</tag>
      </tags>
  </entry>
</search>
