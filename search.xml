<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[匈牙利算法-最小覆盖点]POJ3041题解</title>
    <url>/post1/2021/01/16/</url>
    <content><![CDATA[<h2 id="最小点覆盖"><a href="#最小点覆盖" class="headerlink" title="最小点覆盖"></a>最小点覆盖</h2><h4 id="例题-POJ3041"><a href="#例题-POJ3041" class="headerlink" title="例题: POJ3041"></a><font color=red size=3>例题</font>: <a href="http://poj.org/problem?id=3041">POJ3041</a></h4><h4 id="理解：-有图G-U-V-，求删去最小点可删去所有边的步骤即求最小点覆盖的过程"><a href="#理解：-有图G-U-V-，求删去最小点可删去所有边的步骤即求最小点覆盖的过程" class="headerlink" title="理解： 有图G{U,V}，求删去最小点可删去所有边的步骤即求最小点覆盖的过程"></a><font color=red size=3>理解</font>： 有图G{U,V}，求删去最小点可删去所有边的步骤即求最小点覆盖的过程</h4><hr>
<h5 id="二分图最大匹配的Konig定理及其证明-过于困难-gt-见-http-www-matrix67-com-blog-archives-116"><a href="#二分图最大匹配的Konig定理及其证明-过于困难-gt-见-http-www-matrix67-com-blog-archives-116" class="headerlink" title="二分图最大匹配的König定理及其证明(过于困难)-&gt;见[http://www.matrix67.com/blog/archives/116]"></a>二分图最大匹配的<font color=red size=3>König定理</font>及其证明(过于困难)-&gt;见[<a href="http://www.matrix67.com/blog/archives/116]">http://www.matrix67.com/blog/archives/116]</a></h5><hr>
<h5 id="结论版-Konig定理"><a href="#结论版-Konig定理" class="headerlink" title="结论版 König定理 :"></a>结论版<font color=red size=5> König定理</font> :</h5><ol>
<li>由X侧匹配失败的一点回溯所有边（可见图） 并给走过的点打上标记</li>
<li>X侧未打标记的点和X对侧打标记的点集就是最小点覆盖</li>
</ol>
<img src= "/img/post/post1/post1-img1.jpg" alt = "最小点覆盖"/>
------


<h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a><strong>代码:</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">500</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Max_Match</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">bool</span> g[maxn][maxn];</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="keyword">int</span> left[maxn];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=n;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(left,<span class="number">-1</span>,<span class="keyword">sizeof</span>(left));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">1</span>;v&lt;=n;v++)<span class="keyword">if</span>(g[u][v] &amp;&amp; !vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[v]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(left[v]==<span class="number">-1</span> || match(left[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                left[v]=u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span>(match(i)) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;MM;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    MM.init(n);</span><br><span class="line">    <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">        MM.g[u][v]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,MM.solve());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a><a href="https://zhuanlan.zhihu.com/p/96229700">参考博客</a></h5>]]></content>
      <categories>
        <category>图论</category>
        <category>匈牙利算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>匈牙利算法</tag>
        <tag>最小覆盖点</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>爷 有 片 头 了 ！！！</title>
    <url>/post2/2021/01/16/</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=798539826&cid=279518850&page=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>]]></content>
      <categories>
        <category>bilibili</category>
        <category>csgo</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
        <tag>csgo</tag>
      </tags>
  </entry>
  <entry>
    <title>We have a simple ARG here!</title>
    <url>/post3/2021/01/23/</url>
    <content><![CDATA[<h2 id="0876"><a href="#0876" class="headerlink" title="0876***%"></a>0876***%</h2>]]></content>
      <tags>
        <tag>ARG</tag>
      </tags>
  </entry>
</search>
